Index: examples/axum-echo/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/examples/axum-echo/package.json b/examples/axum-echo/package.json
new file mode 100644
--- /dev/null	(date 1703505176728)
+++ b/examples/axum-echo/package.json	(date 1703505176728)
@@ -0,0 +1,19 @@
+{
+  "name": "axum-echo",
+  "version": "1.0.0",
+  "description": "",
+  "main": "index.js",
+  "scripts": {
+    "test": "echo \"Error: no test specified\" && exit 1",
+    "start": "node index.js"
+  },
+  "repository": {
+    "type": "git",
+    "url": "https://github.com/Totodore/socketioxide.git"
+  },
+  "private": true,
+  "dependencies": {
+    "socket.io-client": "^4.7.2"
+  },
+  "type": "module"
+}
Index: socketioxide/src/socket.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//! A [`Socket`] represents a client connected to a namespace.\n//! The socket struct itself should not be used directly, but through a [`SocketRef`](crate::extract::SocketRef).\nuse std::{\n    borrow::Cow,\n    collections::HashMap,\n    fmt::Debug,\n    sync::Mutex,\n    sync::{\n        atomic::{AtomicI64, Ordering},\n        Arc, RwLock,\n    },\n    time::Duration,\n};\n\nuse engineioxide::socket::DisconnectReason as EIoDisconnectReason;\nuse serde::{de::DeserializeOwned, Serialize};\nuse serde_json::Value;\nuse tokio::sync::oneshot;\n\n#[cfg(feature = \"extensions\")]\nuse crate::extensions::Extensions;\n\nuse crate::{\n    adapter::{Adapter, LocalAdapter, Room},\n    errors::{AckError, Error},\n    handler::{\n        BoxedDisconnectHandler, BoxedMessageHandler, DisconnectHandler, MakeErasedHandler,\n        MessageHandler,\n    },\n    ns::Namespace,\n    operators::{Operators, RoomParam},\n    packet::{BinaryPacket, Packet, PacketData},\n    SocketIoConfig,\n};\nuse crate::{\n    client::SocketData,\n    errors::{AdapterError, SendError},\n};\n\npub use engineioxide::sid::Sid;\n\n/// All the possible reasons for a [`Socket`] to be disconnected from a namespace.\n///\n/// It can be used as an extractor in the [`on_disconnect`](crate::handler::disconnect) handler.\n#[derive(Debug, Copy, Clone, Eq, PartialEq)]\npub enum DisconnectReason {\n    /// The client gracefully closed the connection\n    TransportClose,\n\n    /// The client sent multiple polling requests at the same time (it is forbidden according to the engine.io protocol)\n    MultipleHttpPollingError,\n\n    /// The client sent a bad request / the packet could not be parsed correctly\n    PacketParsingError,\n\n    /// The connection was closed (example: the user has lost connection, or the network was changed from WiFi to 4G)\n    TransportError,\n\n    /// The client did not send a PONG packet in the `ping timeout` delay\n    HeartbeatTimeout,\n\n    /// The client has manually disconnected the socket using [`socket.disconnect()`](https://socket.io/fr/docs/v4/client-api/#socketdisconnect)\n    ClientNSDisconnect,\n\n    /// The socket was forcefully disconnected from the namespace with [`Socket::disconnect`]\n    ServerNSDisconnect,\n\n    /// The server is being closed\n    ClosingServer,\n}\n\nimpl std::fmt::Display for DisconnectReason {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        use DisconnectReason::*;\n        let str: &'static str = match self {\n            TransportClose => \"client gracefully closed the connection\",\n            MultipleHttpPollingError => \"client sent multiple polling requests at the same time\",\n            PacketParsingError => \"client sent a bad request / the packet could not be parsed\",\n            TransportError => \"The connection was abruptly closed\",\n            HeartbeatTimeout => \"client did not send a PONG packet in time\",\n            ClientNSDisconnect => \"client has manually disconnected the socket from the namespace\",\n            ServerNSDisconnect => \"socket was forcefully disconnected from the namespace\",\n            ClosingServer => \"server is being closed\",\n        };\n        f.write_str(str)\n    }\n}\n\nimpl From<EIoDisconnectReason> for DisconnectReason {\n    fn from(reason: EIoDisconnectReason) -> Self {\n        use DisconnectReason::*;\n        match reason {\n            EIoDisconnectReason::TransportClose => TransportClose,\n            EIoDisconnectReason::TransportError => TransportError,\n            EIoDisconnectReason::HeartbeatTimeout => HeartbeatTimeout,\n            EIoDisconnectReason::MultipleHttpPollingError => MultipleHttpPollingError,\n            EIoDisconnectReason::PacketParsingError => PacketParsingError,\n            EIoDisconnectReason::ClosingServer => ClosingServer,\n        }\n    }\n}\n/// An acknowledgement sent by the client.\n/// It contains the data sent by the client and the binary payloads if there are any.\n#[derive(Debug)]\npub struct AckResponse<T> {\n    /// The data returned by the client\n    pub data: T,\n    /// Optional binary payloads\n    ///\n    /// If there is no binary payload, the `Vec` will be empty\n    pub binary: Vec<Vec<u8>>,\n}\n\n/// A Socket represents a client connected to a namespace.\n/// It is used to send and receive messages from the client, join and leave rooms, etc.\n/// The socket struct itself should not be used directly, but through a [`SocketRef`](crate::extract::SocketRef).\npub struct Socket<A: Adapter = LocalAdapter> {\n    config: Arc<SocketIoConfig>,\n    ns: Arc<Namespace<A>>,\n    message_handlers: RwLock<HashMap<Cow<'static, str>, BoxedMessageHandler<A>>>,\n    disconnect_handler: Mutex<Option<BoxedDisconnectHandler<A>>>,\n    ack_message: Mutex<HashMap<i64, oneshot::Sender<AckResponse<Value>>>>,\n    ack_counter: AtomicI64,\n    /// The socket id\n    pub id: Sid,\n\n    /// A type map of protocol extensions.\n    /// It can be used to share data through the lifetime of the socket.\n    /// Because it uses a [`DashMap`](dashmap::DashMap) internally, it is thread safe but be careful about deadlocks!\n    ///\n    /// **Note**: This is note the same data than the `extensions` field on the [`http::Request::extensions()`](http::Request) struct.\n    #[cfg_attr(docsrs, doc(cfg(feature = \"extensions\")))]\n    #[cfg(feature = \"extensions\")]\n    pub extensions: Extensions,\n    esocket: Arc<engineioxide::Socket<SocketData>>,\n}\n\nimpl<A: Adapter> Socket<A> {\n    pub(crate) fn new(\n        sid: Sid,\n        ns: Arc<Namespace<A>>,\n        esocket: Arc<engineioxide::Socket<SocketData>>,\n        config: Arc<SocketIoConfig>,\n    ) -> Self {\n        Self {\n            ns,\n            message_handlers: RwLock::new(HashMap::new()),\n            disconnect_handler: Mutex::new(None),\n            ack_message: Mutex::new(HashMap::new()),\n            ack_counter: AtomicI64::new(0),\n            id: sid,\n            #[cfg(feature = \"extensions\")]\n            extensions: Extensions::new(),\n            config,\n            esocket,\n        }\n    }\n\n    /// ### Registers a [`MessageHandler`] for the given event.\n    ///\n    /// * See the [`message`](crate::handler::message) module doc for more details on message handler.\n    /// * See the [`extract`](crate::extract) module doc for more details on available extractors.\n    ///\n    /// #### Simple example with a sync closure:\n    /// ```\n    /// # use socketioxide::{SocketIo, extract::*};\n    /// # use serde::{Serialize, Deserialize};\n    /// #[derive(Debug, Serialize, Deserialize)]\n    /// struct MyData {\n    ///     name: String,\n    ///     age: u8,\n    /// }\n    ///\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef| {\n    ///     // Register a handler for the \"test\" event and extract the data as a `MyData` struct\n    ///     // With the Data extractor, the handler is called only if the data can be deserialized as a `MyData` struct\n    ///     // If you want to manage errors yourself you can use the TryData extractor\n    ///     socket.on(\"test\", |socket: SocketRef, Data::<MyData>(data)| {\n    ///         println!(\"Received a test message {:?}\", data);\n    ///         socket.emit(\"test-test\", MyData { name: \"Test\".to_string(), age: 8 }).ok(); // Emit a message to the client\n    ///     });\n    /// });\n    ///\n    /// ```\n    ///\n    /// #### Example with a closure and an acknowledgement + binary data:\n    /// ```\n    /// # use socketioxide::{SocketIo, extract::*};\n    /// # use serde_json::Value;\n    /// # use serde::{Serialize, Deserialize};\n    /// #[derive(Debug, Serialize, Deserialize)]\n    /// struct MyData {\n    ///     name: String,\n    ///     age: u8,\n    /// }\n    ///\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef| {\n    ///     // Register an async handler for the \"test\" event and extract the data as a `MyData` struct\n    ///     // Extract the binary payload as a `Vec<Vec<u8>>` with the Bin extractor.\n    ///     // It should be the last extractor because it consumes the request\n    ///     socket.on(\"test\", |socket: SocketRef, Data::<MyData>(data), ack: AckSender, Bin(bin)| async move {\n    ///         println!(\"Received a test message {:?}\", data);\n    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n    ///         ack.bin(bin).send(data).ok(); // The data received is sent back to the client through the ack\n    ///         socket.emit(\"test-test\", MyData { name: \"Test\".to_string(), age: 8 }).ok(); // Emit a message to the client\n    ///     });\n    /// });\n    /// ```\n    pub fn on<H, T>(&self, event: impl Into<Cow<'static, str>>, handler: H)\n    where\n        H: MessageHandler<A, T>,\n        T: Send + Sync + 'static,\n    {\n        self.message_handlers\n            .write()\n            .unwrap()\n            .insert(event.into(), MakeErasedHandler::new_message_boxed(handler));\n    }\n\n    /// ## Registers a disconnect handler.\n    /// You can register only one disconnect handler per socket. If you register multiple handlers, only the last one will be used.\n    ///\n    /// * See the [`disconnect`](crate::handler::disconnect) module doc for more details on disconnect handler.\n    /// * See the [`extract`](crate::extract) module doc for more details on available extractors.\n    ///\n    /// The callback will be called when the socket is disconnected from the server or the client or when the underlying connection crashes.\n    /// A [`DisconnectReason`] is passed to the callback to indicate the reason for the disconnection.\n    /// ### Example\n    /// ```\n    /// # use socketioxide::{SocketIo, socket::DisconnectReason, extract::*};\n    /// # use serde_json::Value;\n    /// # use std::sync::Arc;\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef| {\n    ///     socket.on(\"test\", |socket: SocketRef| async move {\n    ///         // Close the current socket\n    ///         socket.disconnect().ok();\n    ///     });\n    ///     socket.on_disconnect(|socket: SocketRef, reason: DisconnectReason| async move {\n    ///         println!(\"Socket {} on ns {} disconnected, reason: {:?}\", socket.id, socket.ns(), reason);\n    ///     });\n    /// });\n    pub fn on_disconnect<C, T>(&self, callback: C)\n    where\n        C: DisconnectHandler<A, T> + Send + Sync + 'static,\n        T: Send + Sync + 'static,\n    {\n        let handler = MakeErasedHandler::new_disconnect_boxed(callback);\n        self.disconnect_handler.lock().unwrap().replace(handler);\n    }\n\n    /// Emits a message to the client\n    /// ## Errors\n    /// * If the data cannot be serialized to JSON, a [`SendError::Serialize`] is returned.\n    /// * If the packet buffer is full, a [`SendError::InternalChannelFull`] is returned.\n    /// See [`SocketIoBuilder::max_buffer_size`](crate::SocketIoBuilder) option for more infos on internal buffer config\n    /// ## Example\n    /// ```\n    /// # use socketioxide::{SocketIo, extract::*};\n    /// # use serde_json::Value;\n    /// # use std::sync::Arc;\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef| {\n    ///     socket.on(\"test\", |socket: SocketRef, Data::<Value>(data)| async move {\n    ///         // Emit a test message to the client\n    ///         socket.emit(\"test\", data).ok();\n    ///     });\n    /// });\n    /// ```\n    pub fn emit(\n        &self,\n        event: impl Into<Cow<'static, str>>,\n        data: impl Serialize,\n    ) -> Result<(), SendError> {\n        let ns = self.ns();\n        let data = serde_json::to_value(data)?;\n        if let Err(e) = self.send(Packet::event(ns, event.into(), data)) {\n            #[cfg(feature = \"tracing\")]\n            tracing::debug!(\"sending error during emit message: {e:?}\");\n            return Err(e);\n        }\n        Ok(())\n    }\n\n    /// Emits a message to the client and wait for acknowledgement.\n    ///\n    /// The acknowledgement has a timeout specified in the config (5s by default)\n    /// (see [`SocketIoBuilder::ack_timeout`](crate::SocketIoBuilder)) or with the `timeout()` operator.\n    ///\n    /// ## Errors\n    /// * If the data cannot be serialized to JSON, a [`AckError::Serialize`] is returned.\n    /// * If the packet could not be sent, a [`AckError::SendChannel`] is returned.\n    /// * In case of timeout an [`AckError::Timeout`] is returned.\n    /// ##### Example without custom timeout\n    /// ```\n    /// # use socketioxide::{SocketIo, extract::*};\n    /// # use serde_json::Value;\n    /// # use std::sync::Arc;\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef| {\n    ///     socket.on(\"test\", |socket: SocketRef, Data::<Value>(data)| async move {\n    ///         // Emit a test message and wait for an acknowledgement with the timeout specified in the config\n    ///         match socket.emit_with_ack::<Value>(\"test\", data).await {\n    ///             Ok(ack) => println!(\"Ack received {:?}\", ack),\n    ///             Err(err) => println!(\"Ack error {:?}\", err),\n    ///         }\n    ///    });\n    /// });\n    /// ```\n    pub async fn emit_with_ack<V>(\n        &self,\n        event: impl Into<Cow<'static, str>>,\n        data: impl Serialize,\n    ) -> Result<AckResponse<V>, AckError>\n    where\n        V: DeserializeOwned + Send + Sync + 'static,\n    {\n        let ns = self.ns();\n        let data = serde_json::to_value(data)?;\n        let packet = Packet::event(Cow::Borrowed(ns), event.into(), data);\n\n        self.send_with_ack(packet, None).await\n    }\n\n    // Room actions\n\n    /// Joins the given rooms.\n    ///\n    /// If the room does not exist, it will be created.\n    ///\n    /// ## Errors\n    /// When using a distributed adapter, it can return an [`Adapter::Error`] which is mostly related to network errors.\n    /// For the default [`LocalAdapter`] it is always an [`Infallible`](std::convert::Infallible) error\n    pub fn join(&self, rooms: impl RoomParam) -> Result<(), A::Error> {\n        self.ns.adapter.add_all(self.id, rooms)\n    }\n\n    /// Leaves the given rooms.\n    ///\n    /// If the room does not exist, it will do nothing\n    /// ## Errors\n    /// When using a distributed adapter, it can return an [`Adapter::Error`] which is mostly related to network errors.\n    /// For the default [`LocalAdapter`] it is always an [`Infallible`](std::convert::Infallible) error\n    pub fn leave(&self, rooms: impl RoomParam) -> Result<(), A::Error> {\n        self.ns.adapter.del(self.id, rooms)\n    }\n\n    /// Leaves all rooms where the socket is connected.\n    /// ## Errors\n    /// When using a distributed adapter, it can return an [`Adapter::Error`] which is mostly related to network errors.\n    /// For the default [`LocalAdapter`] it is always an [`Infallible`](std::convert::Infallible) error\n    pub fn leave_all(&self) -> Result<(), A::Error> {\n        self.ns.adapter.del_all(self.id)\n    }\n\n    /// Gets all rooms where the socket is connected.\n    /// ## Errors\n    /// When using a distributed adapter, it can return an [`Adapter::Error`] which is mostly related to network errors.\n    /// For the default [`LocalAdapter`] it is always an [`Infallible`](std::convert::Infallible) error\n    pub fn rooms(&self) -> Result<Vec<Room>, A::Error> {\n        self.ns.adapter.socket_rooms(self.id)\n    }\n\n    // Socket operators\n\n    /// Selects all clients in the given rooms except the current socket.\n    ///\n    /// If you want to include the current socket, use the `within()` operator.\n    /// ##### Example\n    /// ```\n    /// # use socketioxide::{SocketIo, extract::*};\n    /// # use serde_json::Value;\n    /// # use std::sync::Arc;\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef| {\n    ///     socket.on(\"test\", |socket: SocketRef, Data::<Value>(data)| async move {\n    ///         let other_rooms = \"room4\".to_string();\n    ///         // In room1, room2, room3 and room4 except the current\n    ///         socket\n    ///             .to(\"room1\")\n    ///             .to([\"room2\", \"room3\"])\n    ///             .to(vec![other_rooms])\n    ///             .emit(\"test\", data);\n    ///     });\n    /// });\n    pub fn to(&self, rooms: impl RoomParam) -> Operators<A> {\n        Operators::new(self.ns.clone(), Some(self.id)).to(rooms)\n    }\n\n    /// Selects all clients in the given rooms.\n    ///\n    /// It does include the current socket contrary to the `to()` operator.\n    /// #### Example\n    /// ```\n    /// # use socketioxide::{SocketIo, extract::*};\n    /// # use serde_json::Value;\n    /// # use std::sync::Arc;\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef| {\n    ///     socket.on(\"test\", |socket: SocketRef, Data::<Value>(data)| async move {\n    ///         let other_rooms = \"room4\".to_string();\n    ///         // In room1, room2, room3 and room4 including the current socket\n    ///         socket\n    ///             .within(\"room1\")\n    ///             .within([\"room2\", \"room3\"])\n    ///             .within(vec![other_rooms])\n    ///             .emit(\"test\", data);\n    ///     });\n    /// });\n    pub fn within(&self, rooms: impl RoomParam) -> Operators<A> {\n        Operators::new(self.ns.clone(), Some(self.id)).within(rooms)\n    }\n\n    /// Filters out all clients selected with the previous operators which are in the given rooms.\n    /// ##### Example\n    /// ```\n    /// # use socketioxide::{SocketIo, extract::*};\n    /// # use serde_json::Value;\n    /// # use std::sync::Arc;\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef| {\n    ///     socket.on(\"register1\", |socket: SocketRef, Data::<Value>(data)| async move {\n    ///         socket.join(\"room1\");\n    ///     });\n    ///     socket.on(\"register2\", |socket: SocketRef, Data::<Value>(data)| async move {\n    ///         socket.join(\"room2\");\n    ///     });\n    ///     socket.on(\"test\", |socket: SocketRef, Data::<Value>(data)| async move {\n    ///         // This message will be broadcast to all clients in the Namespace\n    ///         // except for ones in room1 and the current socket\n    ///         socket.broadcast().except(\"room1\").emit(\"test\", data);\n    ///     });\n    /// });\n    pub fn except(&self, rooms: impl RoomParam) -> Operators<A> {\n        Operators::new(self.ns.clone(), Some(self.id)).except(rooms)\n    }\n\n    /// Broadcasts to all clients only connected on this node (when using multiple nodes).\n    /// When using the default in-memory [`LocalAdapter`], this operator is a no-op.\n    /// ##### Example\n    /// ```\n    /// # use socketioxide::{SocketIo, extract::*};\n    /// # use serde_json::Value;\n    /// # use std::sync::Arc;\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef| {\n    ///     socket.on(\"test\", |socket: SocketRef, Data::<Value>(data)| async move {\n    ///         // This message will be broadcast to all clients in this namespace and connected on this node\n    ///         socket.local().emit(\"test\", data);\n    ///     });\n    /// });\n    pub fn local(&self) -> Operators<A> {\n        Operators::new(self.ns.clone(), Some(self.id)).local()\n    }\n\n    /// Sets a custom timeout when sending a message with an acknowledgement.\n    ///\n    /// ##### Example\n    /// ```\n    /// # use socketioxide::{SocketIo, extract::*};\n    /// # use serde_json::Value;\n    /// # use futures::stream::StreamExt;\n    /// # use std::time::Duration;\n    /// # use std::sync::Arc;\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef| {\n    ///    socket.on(\"test\", |socket: SocketRef, Data::<Value>(data), Bin(bin)| async move {\n    ///       // Emit a test message in the room1 and room3 rooms, except for the room2 room with the binary payload received, wait for 5 seconds for an acknowledgement\n    ///       socket.to(\"room1\")\n    ///             .to(\"room3\")\n    ///             .except(\"room2\")\n    ///             .bin(bin)\n    ///             .timeout(Duration::from_secs(5))\n    ///             .emit_with_ack::<Value>(\"message-back\", data).unwrap().for_each(|ack| async move {\n    ///                match ack {\n    ///                    Ok(ack) => println!(\"Ack received {:?}\", ack),\n    ///                    Err(err) => println!(\"Ack error {:?}\", err),\n    ///                }\n    ///             }).await;\n    ///    });\n    /// });\n    ///\n    pub fn timeout(&self, timeout: Duration) -> Operators<A> {\n        Operators::new(self.ns.clone(), Some(self.id)).timeout(timeout)\n    }\n\n    /// Adds a binary payload to the message.\n    /// ##### Example\n    /// ```\n    /// # use socketioxide::{SocketIo, extract::*};\n    /// # use serde_json::Value;\n    /// # use std::sync::Arc;\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef| {\n    ///     socket.on(\"test\", |socket: SocketRef, Data::<Value>(data), Bin(bin)| async move {\n    ///         // This will send the binary payload received to all clients in this namespace with the test message\n    ///         socket.bin(bin).emit(\"test\", data);\n    ///     });\n    /// });\n    pub fn bin(&self, binary: Vec<Vec<u8>>) -> Operators<A> {\n        Operators::new(self.ns.clone(), Some(self.id)).bin(binary)\n    }\n\n    /// Broadcasts to all clients without any filtering (except the current socket).\n    /// ##### Example\n    /// ```\n    /// # use socketioxide::{SocketIo, extract::*};\n    /// # use serde_json::Value;\n    /// # use std::sync::Arc;\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef| {\n    ///     socket.on(\"test\", |socket: SocketRef, Data::<Value>(data)| async move {\n    ///         // This message will be broadcast to all clients in this namespace\n    ///         socket.broadcast().emit(\"test\", data);\n    ///     });\n    /// });\n    pub fn broadcast(&self) -> Operators<A> {\n        Operators::new(self.ns.clone(), Some(self.id)).broadcast()\n    }\n\n    /// Disconnects the socket from the current namespace,\n    ///\n    /// It will also call the disconnect handler if it is set.\n    pub fn disconnect(self: Arc<Self>) -> Result<(), SendError> {\n        self.send(Packet::disconnect(&self.ns.path))?;\n        self.close(DisconnectReason::ServerNSDisconnect)?;\n        Ok(())\n    }\n\n    /// Closes the engine.io connection if it is not already closed.\n    /// Return a future that resolves when the underlying transport is closed.\n    pub(crate) async fn close_underlying_transport(&self) {\n        if !self.esocket.is_closed() {\n            #[cfg(feature = \"tracing\")]\n            tracing::debug!(\"closing underlying transport for socket: {}\", self.id);\n            self.esocket.close(EIoDisconnectReason::ClosingServer);\n        }\n        self.esocket.closed().await;\n    }\n\n    /// Gets the current namespace path.\n    pub fn ns(&self) -> &str {\n        &self.ns.path\n    }\n\n    pub(crate) fn send(&self, mut packet: Packet<'_>) -> Result<(), SendError> {\n        let bin_payloads = match packet.inner {\n            PacketData::BinaryEvent(_, ref mut bin, _) | PacketData::BinaryAck(ref mut bin, _) => {\n                Some(std::mem::take(&mut bin.bin))\n            }\n            _ => None,\n        };\n\n        let msg = packet.try_into()?;\n        self.esocket.emit(msg)?;\n        if let Some(bin_payloads) = bin_payloads {\n            for bin in bin_payloads {\n                self.esocket.emit_binary(bin)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    pub(crate) async fn send_with_ack<'a, V: DeserializeOwned>(\n        &self,\n        mut packet: Packet<'a>,\n        timeout: Option<Duration>,\n    ) -> Result<AckResponse<V>, AckError> {\n        let (tx, rx) = oneshot::channel();\n        let ack = self.ack_counter.fetch_add(1, Ordering::SeqCst) + 1;\n        self.ack_message.lock().unwrap().insert(ack, tx);\n        packet.inner.set_ack_id(ack);\n        self.send(packet)?;\n        let timeout = timeout.unwrap_or(self.config.ack_timeout);\n        let v = tokio::time::timeout(timeout, rx).await??;\n        Ok(AckResponse {\n            data: serde_json::from_value(v.data)?,\n            binary: v.binary,\n        })\n    }\n\n    /// Called when the socket is gracefully disconnected from the server or the client\n    ///\n    /// It maybe also close when the underlying transport is closed or failed.\n    pub(crate) fn close(self: Arc<Self>, reason: DisconnectReason) -> Result<(), AdapterError> {\n        if let Some(handler) = self.disconnect_handler.lock().unwrap().take() {\n            handler.call(self.clone(), reason);\n        }\n\n        self.ns.remove_socket(self.id)?;\n        Ok(())\n    }\n\n    // Receives data from client:\n    pub(crate) fn recv(self: Arc<Self>, packet: PacketData<'_>) -> Result<(), Error> {\n        match packet {\n            PacketData::Event(e, data, ack) => self.recv_event(&e, data, ack),\n            PacketData::EventAck(data, ack_id) => self.recv_ack(data, ack_id),\n            PacketData::BinaryEvent(e, packet, ack) => self.recv_bin_event(&e, packet, ack),\n            PacketData::BinaryAck(packet, ack) => self.recv_bin_ack(packet, ack),\n            PacketData::Disconnect => self\n                .close(DisconnectReason::ClientNSDisconnect)\n                .map_err(Error::from),\n            _ => unreachable!(),\n        }\n    }\n\n    /// Gets the request info made by the client to connect\n    ///\n    /// Note that the `extensions` field will be empty and will not\n    /// contain extensions set in the previous http layers for requests initialized with ws transport.\n    ///\n    /// It is because [`http::Extensions`] is not cloneable and is needed for ws upgrade.\n    pub fn req_parts(&self) -> &http::request::Parts {\n        &self.esocket.req_parts\n    }\n\n    /// Gets the [`TransportType`](crate::TransportType) used by the client to connect with this [`Socket`]\n    ///\n    /// It can also be accessed as an extractor:\n    /// ```\n    /// # use socketioxide::{SocketIo, TransportType, extract::*};\n    ///\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef, transport: TransportType| {\n    ///     assert_eq!(socket.transport_type(), transport);\n    /// });\n    pub fn transport_type(&self) -> crate::TransportType {\n        self.esocket.transport_type()\n    }\n\n    /// Gets the socket.io [`ProtocolVersion`](crate::ProtocolVersion) used by the client to connect with this [`Socket`]\n    ///\n    /// It can also be accessed as an extractor:\n    /// ## Example\n    /// ```\n    /// # use socketioxide::{SocketIo, ProtocolVersion, extract::*};\n    ///\n    /// let (_, io) = SocketIo::new_svc();\n    /// io.ns(\"/\", |socket: SocketRef, v: ProtocolVersion| {\n    ///     assert_eq!(socket.protocol(), v);\n    /// });\n    pub fn protocol(&self) -> crate::ProtocolVersion {\n        self.esocket.protocol.into()\n    }\n\n    fn recv_event(self: Arc<Self>, e: &str, data: Value, ack: Option<i64>) -> Result<(), Error> {\n        if let Some(handler) = self.message_handlers.read().unwrap().get(e) {\n            handler.call(self.clone(), data, vec![], ack);\n        }\n        Ok(())\n    }\n\n    fn recv_bin_event(\n        self: Arc<Self>,\n        e: &str,\n        packet: BinaryPacket,\n        ack: Option<i64>,\n    ) -> Result<(), Error> {\n        if let Some(handler) = self.message_handlers.read().unwrap().get(e) {\n            handler.call(self.clone(), packet.data, packet.bin, ack);\n        }\n        Ok(())\n    }\n\n    fn recv_ack(self: Arc<Self>, data: Value, ack: i64) -> Result<(), Error> {\n        if let Some(tx) = self.ack_message.lock().unwrap().remove(&ack) {\n            let res = AckResponse {\n                data,\n                binary: vec![],\n            };\n            tx.send(res).ok();\n        }\n        Ok(())\n    }\n\n    fn recv_bin_ack(self: Arc<Self>, packet: BinaryPacket, ack: i64) -> Result<(), Error> {\n        if let Some(tx) = self.ack_message.lock().unwrap().remove(&ack) {\n            let res = AckResponse {\n                data: packet.data,\n                binary: packet.bin,\n            };\n            tx.send(res).ok();\n        }\n        Ok(())\n    }\n}\n\nimpl<A: Adapter> Debug for Socket<A> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"Socket\")\n            .field(\"ns\", &self.ns())\n            .field(\"ack_message\", &self.ack_message)\n            .field(\"ack_counter\", &self.ack_counter)\n            .field(\"sid\", &self.id)\n            .finish()\n    }\n}\n\n#[cfg(test)]\nimpl<A: Adapter> Socket<A> {\n    pub fn new_dummy(sid: Sid, ns: Arc<Namespace<A>>) -> Socket<A> {\n        let close_fn = Box::new(move |_, _| ());\n        Socket::new(\n            sid,\n            ns,\n            engineioxide::Socket::new_dummy(sid, close_fn).into(),\n            Arc::new(SocketIoConfig::default()),\n        )\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/socketioxide/src/socket.rs b/socketioxide/src/socket.rs
--- a/socketioxide/src/socket.rs	(revision b9e22e03ae80f41e2720111afaae748e8d38bbae)
+++ b/socketioxide/src/socket.rs	(date 1703514694292)
@@ -38,6 +38,7 @@
 };
 
 pub use engineioxide::sid::Sid;
+use crate::operators_single::OperatorsSingle;
 
 /// All the possible reasons for a [`Socket`] to be disconnected from a namespace.
 ///
@@ -274,14 +275,7 @@
         event: impl Into<Cow<'static, str>>,
         data: impl Serialize,
     ) -> Result<(), SendError> {
-        let ns = self.ns();
-        let data = serde_json::to_value(data)?;
-        if let Err(e) = self.send(Packet::event(ns, event.into(), data)) {
-            #[cfg(feature = "tracing")]
-            tracing::debug!("sending error during emit message: {e:?}");
-            return Err(e);
-        }
-        Ok(())
+        OperatorsSingle::new(self).emit(event, data)
     }
 
     /// Emits a message to the client and wait for acknowledgement.
@@ -317,11 +311,7 @@
     where
         V: DeserializeOwned + Send + Sync + 'static,
     {
-        let ns = self.ns();
-        let data = serde_json::to_value(data)?;
-        let packet = Packet::event(Cow::Borrowed(ns), event.into(), data);
-
-        self.send_with_ack(packet, None).await
+        OperatorsSingle::new(self).emit_with_ack(event, data).await
     }
 
     // Room actions
Index: socketioxide/src/operators_single.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/socketioxide/src/operators_single.rs b/socketioxide/src/operators_single.rs
new file mode 100644
--- /dev/null	(date 1703524230684)
+++ b/socketioxide/src/operators_single.rs	(date 1703524230684)
@@ -0,0 +1,142 @@
+//! [`OperatorsSingle`] are used to select sockets to send a packet to, or to configure the packet that will be emitted.
+//! It uses the builder pattern to chain operators.
+use std::borrow::Cow;
+use std::{time::Duration};
+
+use serde::de::DeserializeOwned;
+use serde::Serialize;
+use engineioxide::{Packet, Socket};
+
+use crate::adapter::LocalAdapter;
+use crate::socket::AckResponse;
+use crate::{adapter::{Adapter}, errors::AckError, SendError};
+
+/// Operators are used to select sockets to send a packet to, or to configure the packet that will be emitted.
+#[derive(Debug)]
+pub struct OperatorsSingle<A: Adapter = LocalAdapter> {
+    socket: Socket<A>,
+    timeout: Option<Duration>,
+    binary: Vec<Vec<u8>>,
+}
+
+impl<A: Adapter> OperatorsSingle<A> {
+    pub(crate) fn new(socket: Socket<A>) -> Self {
+        Self {
+            socket,
+            timeout: None,
+            binary: vec![],
+        }
+    }
+
+    pub fn timeout(mut self, timeout: Duration) -> Self {
+        self.timeout = Some(timeout);
+        self
+    }
+
+    /// Adds a binary payload to the message.
+    /// #### Example
+    /// ```
+    /// # use socketioxide::{SocketIo, extract::*};
+    /// # use serde_json::Value;
+    /// let (_, io) = SocketIo::new_svc();
+    /// io.ns("/", |socket: SocketRef| {
+    ///     socket.on("test", |socket: SocketRef, Data::<Value>(data), Bin(bin)| async move {
+    ///         // This will send the binary payload to the socket with the test message
+    ///         socket.bin(bin).emit("test", data);
+    ///     });
+    /// });
+    pub fn bin(mut self, binary: Vec<Vec<u8>>) -> Self {
+        self.binary = binary;
+        self
+    }
+
+    /// Emits a message to the client
+    /// ## Errors
+    /// * If the data cannot be serialized to JSON, a [`SendError::Serialize`] is returned.
+    /// * If the packet buffer is full, a [`SendError::InternalChannelFull`] is returned.
+    /// See [`SocketIoBuilder::max_buffer_size`](crate::SocketIoBuilder) option for more infos on internal buffer config
+    /// ## Example
+    /// ```
+    /// # use socketioxide::{SocketIo, extract::*};
+    /// # use serde_json::Value;
+    /// # use std::sync::Arc;
+    /// let (_, io) = SocketIo::new_svc();
+    /// io.ns("/", |socket: SocketRef| {
+    ///     socket.on("test", |socket: SocketRef, Data::<Value>(data)| async move {
+    ///         // Emit a test message to the client
+    ///         socket.emit("test", data).ok();
+    ///     });
+    /// });
+    /// ```
+    pub fn emit(
+        mut self,
+        event: impl Into<Cow<'static, str>>,
+        data: impl Serialize,
+    ) -> Result<(), SendError> {
+        let ns = self.ns();
+        let data = serde_json::to_value(data)?;
+        if let Err(e) = self.socket.send(Packet::event(ns, event.into(), data)) {
+            #[cfg(feature = "tracing")]
+            tracing::debug!("sending error during emit message: {e:?}");
+            return Err(SendError::from(e));
+        }
+        Ok(())
+    }
+
+    /// Emits a message to the client and wait for acknowledgement.
+    ///
+    /// The acknowledgement has a timeout specified in the config (5s by default)
+    /// (see [`SocketIoBuilder::ack_timeout`](crate::SocketIoBuilder)) or with the `timeout()` operator.
+    ///
+    /// ## Errors
+    /// * If the data cannot be serialized to JSON, a [`AckError::Serialize`] is returned.
+    /// * If the packet could not be sent, a [`AckError::SendChannel`] is returned.
+    /// * In case of timeout an [`AckError::Timeout`] is returned.
+    /// ##### Example without custom timeout
+    /// ```
+    /// # use socketioxide::{SocketIo, extract::*};
+    /// # use serde_json::Value;
+    /// # use std::sync::Arc;
+    /// let (_, io) = SocketIo::new_svc();
+    /// io.ns("/", |socket: SocketRef| {
+    ///     socket.on("test", |socket: SocketRef, Data::<Value>(data)| async move {
+    ///         // Emit a test message and wait for an acknowledgement with the timeout specified in the config
+    ///         match socket.emit_with_ack::<Value>("test", data).await {
+    ///             Ok(ack) => println!("Ack received {:?}", ack),
+    ///             Err(err) => println!("Ack error {:?}", err),
+    ///         }
+    ///    });
+    /// });
+    /// ```
+    pub async fn emit_with_ack<V>(
+        &self,
+        event: impl Into<Cow<'static, str>>,
+        data: impl Serialize,
+    ) -> Result<AckResponse<V>, AckError>
+        where
+            V: DeserializeOwned + Send + Sync + 'static,
+    {
+        let ns = self.socket.ns();
+        let data = serde_json::to_value(data)?;
+        let packet = Packet::event(Cow::Borrowed(ns), event.into(), data);
+
+        self.send_with_ack(packet, None).await
+    }
+
+    /// Creates a packet with the given event and data.
+    fn get_packet(
+        &mut self,
+        event: impl Into<Cow<'static, str>>,
+        data: impl serde::Serialize,
+    ) -> Result<Packet<'static>, serde_json::Error> {
+        let ns = self.socket.ns();
+        let data = serde_json::to_value(data)?;
+        let packet = if self.binary.is_empty() {
+            Packet::event(ns, event.into(), data)
+        } else {
+            let binary = std::mem::take(&mut self.binary);
+            Packet::bin_event(ns, event.into(), data, binary)
+        };
+        Ok(packet)
+    }
+}
\ No newline at end of file
Index: engineioxide/src/socket.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//! ## A [`Socket`] represents a client connection to the server\n//!\n//! It can be used to :\n//! * Emit binary or string data\n//! * Get a reference to the request made to connect to the socket.io server\n//! * Close the connection\n//!\n//! #### Example :\n//! ```rust\n//! # use engineioxide::service::EngineIoService;\n//! # use engineioxide::handler::EngineIoHandler;\n//! # use engineioxide::{Socket, DisconnectReason};\n//! # use std::sync::{Mutex, Arc};\n//! # use std::sync::atomic::{AtomicUsize, Ordering};\n//! // Global state\n//! #[derive(Debug, Default)]\n//! struct MyHandler {\n//!     user_cnt: AtomicUsize,\n//! }\n//!\n//! // Socket state\n//! #[derive(Debug, Default)]\n//! struct SocketState {\n//!     id: Mutex<String>,\n//! }\n//!\n//! impl EngineIoHandler for MyHandler {\n//!     type Data = SocketState;\n//!\n//!     fn on_connect(&self, socket: Arc<Socket<SocketState>>) {\n//!         // Get the request made to initialize the connection\n//!         // and check that the authorization header is correct\n//!         let connected = socket.req_parts.headers.get(\"Authorization\")\n//!             .map(|a| a == \"mysuperpassword!\").unwrap_or_default();\n//!         // Close the socket if the authentication is invalid\n//!         if !connected {\n//!             socket.close(DisconnectReason::TransportError);\n//!             return;\n//!         }\n//!\n//!         let cnt = self.user_cnt.fetch_add(1, Ordering::Relaxed) + 1;\n//!         // Emit string data to the client\n//!         socket.emit(cnt.to_string()).ok();\n//!     }\n//!     fn on_disconnect(&self, socket: Arc<Socket<SocketState>>, reason: DisconnectReason) {\n//!         let cnt = self.user_cnt.fetch_sub(1, Ordering::Relaxed) - 1;\n//!     }\n//!     fn on_message(&self, msg: String, socket: Arc<Socket<SocketState>>) {\n//!         *socket.data.id.lock().unwrap() = msg; // bind a provided user id to a socket\n//!     }\n//!     fn on_binary(&self, data: Vec<u8>, socket: Arc<Socket<SocketState>>) { }\n//! }\n//!\n//! let svc = EngineIoService::new(MyHandler::default());\n//! ```\nuse std::{\n    sync::{\n        atomic::{AtomicU8, Ordering},\n        Arc,\n    },\n    time::Duration,\n};\n\nuse http::request::Parts;\nuse tokio::{\n    sync::{\n        mpsc::{self},\n        mpsc::{error::TrySendError, Receiver},\n        Mutex,\n    },\n    task::JoinHandle,\n};\nuse tokio_tungstenite::tungstenite;\n\nuse crate::{\n    config::EngineIoConfig, errors::Error, packet::Packet, peekable::PeekableReceiver,\n    service::ProtocolVersion,\n};\nuse crate::{service::TransportType, sid::Sid};\n\n/// A [`DisconnectReason`] represents the reason why a [`Socket`] was closed.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum DisconnectReason {\n    /// The client gracefully closed the connection\n    TransportClose,\n    /// The client sent multiple polling requests at the same time (it is forbidden according to the engine.io protocol)\n    MultipleHttpPollingError,\n    /// The client sent a bad request / the packet could not be parsed correctly\n    PacketParsingError,\n    /// An error occured in the transport layer\n    /// (e.g. the client closed the connection without sending a close packet)\n    TransportError,\n    /// The client did not respond to the heartbeat\n    HeartbeatTimeout,\n    /// The server is being closed\n    ClosingServer,\n}\n\n/// Convert an [`Error`] to a [`DisconnectReason`] if possible\n/// This is used to notify the [`Handler`](crate::handler::EngineIoHandler) of the reason why a [`Socket`] was closed\n/// If the error cannot be converted to a [`DisconnectReason`] it means that the error was not fatal and the [`Socket`] can be kept alive\nimpl From<&Error> for Option<DisconnectReason> {\n    fn from(err: &Error) -> Self {\n        use Error::*;\n        match err {\n            WsTransport(tungstenite::Error::ConnectionClosed) => None,\n            WsTransport(_) | Io(_) => Some(DisconnectReason::TransportError),\n            BadPacket(_) | Serialize(_) | Base64(_) | StrUtf8(_) | PayloadTooLarge\n            | InvalidPacketLength | InvalidPacketType(_) => {\n                Some(DisconnectReason::PacketParsingError)\n            }\n            HeartbeatTimeout => Some(DisconnectReason::HeartbeatTimeout),\n            _ => None,\n        }\n    }\n}\n\n/// A [`Socket`] represents a client connection to the server.\n/// It is agnostic to the [`TransportType`].\n///\n/// It handles :\n/// * the packet communication between with the `Engine`\n/// and the user defined [`Handler`](crate::handler::EngineIoHandler).\n/// * the user defined [`Data`](crate::handler::EngineIoHandler::Data) bound to the socket.\n/// * the heartbeat job that verify that the connection is still up by sending packets periodically.\npub struct Socket<D>\nwhere\n    D: Default + Send + Sync + 'static,\n{\n    /// The socket id\n    pub id: Sid,\n\n    /// The protocol version used by the socket\n    pub protocol: ProtocolVersion,\n\n    /// The transport type represented as a bitfield\n    /// It is represented as a bitfield to allow the use of an [`AtomicU8`] so it can be shared between threads\n    /// without any mutex\n    transport: AtomicU8,\n\n    /// Channel to receive [`Packet`] from the connection\n    ///\n    /// It is used and managed by the [`EngineIo`](crate::engine) struct depending on the transport type\n    ///\n    /// It is locked if [`EngineIo`](crate::engine) is currently reading from it :\n    /// * In case of polling transport it will be locked and released for each request\n    /// * In case of websocket transport it will be always locked until the connection is closed\n    ///\n    /// It will be closed when a [`Close`](Packet::Close) packet is received:\n    /// * From the [encoder](crate::service::encoder) if the transport is polling\n    /// * From the fn [`on_ws_req_init`](crate::engine::EngineIo) if the transport is websocket\n    /// * Automatically via the [`close_session fn`](crate::engine::EngineIo::close_session) as a fallback.\n    /// Because with polling transport, if the client is not currently polling then the encoder will never be able to close the channel\n    pub(crate) internal_rx: Mutex<PeekableReceiver<Packet>>,\n\n    /// Channel to send [Packet] to the internal connection\n    internal_tx: mpsc::Sender<Packet>,\n\n    /// Internal channel to receive Pong [`Packets`](Packet) (v4 protocol) or Ping (v3 protocol) in the heartbeat job\n    /// which is running in a separate task\n    heartbeat_rx: Mutex<Receiver<()>>,\n    /// Channel to send Ping [`Packets`](Packet) (v4 protocol) or Ping (v3 protocol) from the connexion to the heartbeat job\n    /// which is running in a separate task\n    pub(crate) heartbeat_tx: mpsc::Sender<()>,\n    /// Handle to the heartbeat job so that it can be aborted when the socket is closed\n    heartbeat_handle: Mutex<Option<JoinHandle<()>>>,\n\n    /// Function to call when the socket is closed\n    close_fn: Box<dyn Fn(Sid, DisconnectReason) + Send + Sync>,\n    /// User data bound to the socket\n    pub data: D,\n\n    /// Http Request data used to create a socket\n    pub req_parts: Parts,\n\n    /// If the client supports binary packets (via polling XHR2)\n    #[cfg(feature = \"v3\")]\n    pub(crate) supports_binary: bool,\n}\n\nimpl<D> Socket<D>\nwhere\n    D: Default + Send + Sync + 'static,\n{\n    pub(crate) fn new(\n        protocol: ProtocolVersion,\n        transport: TransportType,\n        config: &EngineIoConfig,\n        req_parts: Parts,\n        close_fn: Box<dyn Fn(Sid, DisconnectReason) + Send + Sync>,\n        #[cfg(feature = \"v3\")] supports_binary: bool,\n    ) -> Self {\n        let (internal_tx, internal_rx) = mpsc::channel(config.max_buffer_size);\n        let (heartbeat_tx, heartbeat_rx) = mpsc::channel(1);\n\n        Self {\n            id: Sid::new(),\n            protocol,\n            transport: AtomicU8::new(transport as u8),\n\n            internal_rx: Mutex::new(PeekableReceiver::new(internal_rx)),\n            internal_tx,\n\n            heartbeat_rx: Mutex::new(heartbeat_rx),\n            heartbeat_tx,\n            heartbeat_handle: Mutex::new(None),\n            close_fn,\n\n            data: D::default(),\n            req_parts,\n\n            #[cfg(feature = \"v3\")]\n            supports_binary,\n        }\n    }\n\n    /// Abort the heartbeat job if it is running\n    pub(crate) fn abort_heartbeat(&self) {\n        if let Ok(Some(handle)) = self.heartbeat_handle.try_lock().map(|mut h| h.take()) {\n            handle.abort();\n        }\n    }\n\n    /// Sends a packet to the connection.\n    pub(crate) fn send(&self, packet: Packet) -> Result<(), TrySendError<Packet>> {\n        #[cfg(feature = \"tracing\")]\n        tracing::debug!(\"[sid={}] sending packet: {:?}\", self.id, packet);\n        self.internal_tx.try_send(packet)?;\n        Ok(())\n    }\n\n    /// Spawn the heartbeat job\n    ///\n    /// Keep a handle to the job so that it can be aborted when the socket is closed\n    pub(crate) fn spawn_heartbeat(self: Arc<Self>, interval: Duration, timeout: Duration) {\n        let socket = self.clone();\n\n        let handle = tokio::spawn(async move {\n            if let Err(_e) = socket.heartbeat_job(interval, timeout).await {\n                socket.close(DisconnectReason::HeartbeatTimeout);\n                #[cfg(feature = \"tracing\")]\n                tracing::debug!(\"[sid={}] heartbeat error: {:?}\", socket.id, _e);\n            }\n        });\n        self.heartbeat_handle\n            .try_lock()\n            .expect(\"heartbeat handle mutex should not be locked twice\")\n            .replace(handle);\n    }\n\n    /// Heartbeat is sent every `interval` milliseconds by the client and the server is expected to respond within `timeout` milliseconds.\n    ///\n    /// If the client or server does not respond within the timeout, the connection is closed.\n    #[cfg(feature = \"v3\")]\n    async fn heartbeat_job(&self, interval: Duration, timeout: Duration) -> Result<(), Error> {\n        match self.protocol {\n            ProtocolVersion::V3 => self.heartbeat_job_v3(interval, timeout).await,\n            ProtocolVersion::V4 => self.heartbeat_job_v4(interval, timeout).await,\n        }\n    }\n\n    /// Heartbeat is sent every `interval` milliseconds and the client is expected to respond within `timeout` milliseconds.\n    ///\n    /// If the client does not respond within the timeout, the connection is closed.\n    #[cfg(not(feature = \"v3\"))]\n    async fn heartbeat_job(&self, interval: Duration, timeout: Duration) -> Result<(), Error> {\n        self.heartbeat_job_v4(interval, timeout).await\n    }\n\n    /// Heartbeat is sent every `interval` milliseconds and the client is expected to respond within `timeout` milliseconds.\n    ///\n    /// If the client does not respond within the timeout, the connection is closed.\n    async fn heartbeat_job_v4(&self, interval: Duration, timeout: Duration) -> Result<(), Error> {\n        let mut heartbeat_rx = self\n            .heartbeat_rx\n            .try_lock()\n            .expect(\"Pong rx should be locked only once\");\n\n        let instant = tokio::time::Instant::now();\n        let mut interval_tick = tokio::time::interval(interval);\n        interval_tick.tick().await;\n        // Sleep for an interval minus the time it took to get here\n        tokio::time::sleep(interval.saturating_sub(Duration::from_millis(\n            15 + instant.elapsed().as_millis() as u64,\n        )))\n        .await;\n\n        #[cfg(feature = \"tracing\")]\n        tracing::debug!(\"[sid={}] heartbeat sender routine started\", self.id);\n\n        loop {\n            // Some clients send the pong packet in first. If that happens, we should consume it.\n            heartbeat_rx.try_recv().ok();\n\n            self.internal_tx\n                .try_send(Packet::Ping)\n                .map_err(|_| Error::HeartbeatTimeout)?;\n            tokio::time::timeout(timeout, heartbeat_rx.recv())\n                .await\n                .map_err(|_| Error::HeartbeatTimeout)?\n                .ok_or(Error::HeartbeatTimeout)?;\n            interval_tick.tick().await;\n        }\n    }\n\n    #[cfg(feature = \"v3\")]\n    async fn heartbeat_job_v3(&self, interval: Duration, timeout: Duration) -> Result<(), Error> {\n        let mut heartbeat_rx = self\n            .heartbeat_rx\n            .try_lock()\n            .expect(\"Pong rx should be locked only once\");\n\n        #[cfg(feature = \"tracing\")]\n        tracing::debug!(\"[sid={}] heartbeat receiver routine started\", self.id);\n\n        loop {\n            tokio::time::timeout(interval + timeout, heartbeat_rx.recv())\n                .await\n                .map_err(|_| Error::HeartbeatTimeout)?\n                .ok_or(Error::HeartbeatTimeout)?;\n\n            #[cfg(feature = \"tracing\")]\n            tracing::debug!(\"[sid={}] ping received, sending pong\", self.id);\n            self.internal_tx\n                .try_send(Packet::Pong)\n                .map_err(|_| Error::HeartbeatTimeout)?;\n        }\n    }\n\n    /// Returns true if the [`Socket`] has a websocket [`TransportType`]\n    pub(crate) fn is_ws(&self) -> bool {\n        self.transport.load(Ordering::Relaxed) == TransportType::Websocket as u8\n    }\n    /// returns true if the [`Socket`] has an HTTP [`TransportType`]\n    pub(crate) fn is_http(&self) -> bool {\n        self.transport.load(Ordering::Relaxed) == TransportType::Polling as u8\n    }\n\n    /// Sets the [`TransportType`] to WebSocket\n    /// Used when the client upgrade the connection from HTTP to WebSocket\n    pub(crate) fn upgrade_to_websocket(&self) {\n        self.transport\n            .store(TransportType::Websocket as u8, Ordering::Relaxed);\n    }\n\n    /// Returns the current [`TransportType`] of the [`Socket`]\n    pub fn transport_type(&self) -> TransportType {\n        TransportType::from(self.transport.load(Ordering::Relaxed))\n    }\n\n    /// Emits a message to the client.\n    ///\n    /// If the transport is in websocket mode, the message is directly sent as a text frame.\n    ///\n    /// If the transport is in polling mode, the message is buffered and sent as a text frame to the next polling request.\n    ///\n    /// \uFE0F If the buffer is full or the socket is disconnected, an error will be returned with the original data\n    pub fn emit(&self, msg: String) -> Result<(), TrySendError<String>> {\n        self.send(Packet::Message(msg)).map_err(|e| match e {\n            TrySendError::Full(p) => TrySendError::Full(p.into_message()),\n            TrySendError::Closed(p) => TrySendError::Closed(p.into_message()),\n        })\n    }\n\n    /// Immediately closes the socket and the underlying connection.\n    /// The socket will be removed from the `Engine` and the [`Handler`](crate::handler::EngineIoHandler) will be notified.\n    pub fn close(&self, reason: DisconnectReason) {\n        (self.close_fn)(self.id, reason);\n        self.send(Packet::Close).ok();\n    }\n\n    /// Returns true if the socket is closed\n    /// It means that no more packets can be sent to the client\n    pub fn is_closed(&self) -> bool {\n        self.internal_tx.is_closed()\n    }\n\n    /// Wait for the socket to be fully closed\n    pub async fn closed(&self) {\n        self.internal_tx.closed().await\n    }\n\n    /// Emits a binary message to the client.\n    ///\n    /// If the transport is in websocket mode, the message is directly sent as a binary frame.\n    ///\n    /// If the transport is in polling mode, the message is buffered and sent as a text frame **encoded in base64** to the next polling request.\n    ///\n    /// \uFE0F If the buffer is full or the socket is disconnected, an error will be returned with the original data\n    pub fn emit_binary(&self, data: Vec<u8>) -> Result<(), TrySendError<Vec<u8>>> {\n        if self.protocol == ProtocolVersion::V3 {\n            self.send(Packet::BinaryV3(data))\n        } else {\n            self.send(Packet::Binary(data))\n        }\n        .map_err(|e| match e {\n            TrySendError::Full(p) => TrySendError::Full(p.into_binary()),\n            TrySendError::Closed(p) => TrySendError::Closed(p.into_binary()),\n        })\n    }\n}\n\nimpl<D: Default + Send + Sync + 'static> std::fmt::Debug for Socket<D> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"Socket\")\n            .field(\"sid\", &self.id)\n            .field(\"protocol\", &self.protocol)\n            .field(\"conn\", &self.transport)\n            .field(\"internal_rx\", &self.internal_rx)\n            .field(\"internal_tx\", &self.internal_tx)\n            .field(\"heartbeat_rx\", &self.heartbeat_rx)\n            .field(\"heartbeat_tx\", &self.heartbeat_tx)\n            .field(\"heartbeat_handle\", &self.heartbeat_handle)\n            .field(\"req_data\", &self.req_parts)\n            .finish()\n    }\n}\n\n#[cfg(feature = \"test-utils\")]\nimpl<D> Drop for Socket<D>\nwhere\n    D: Default + Send + Sync + 'static,\n{\n    fn drop(&mut self) {\n        #[cfg(feature = \"tracing\")]\n        tracing::debug!(\"[sid={}] dropping socket\", self.id);\n    }\n}\n\n#[cfg(feature = \"test-utils\")]\nimpl<D> Socket<D>\nwhere\n    D: Default + Send + Sync + 'static,\n{\n    /// Create a dummy socket for testing purpose\n    pub fn new_dummy(\n        sid: Sid,\n        close_fn: Box<dyn Fn(Sid, DisconnectReason) + Send + Sync>,\n    ) -> Socket<D> {\n        let (internal_tx, internal_rx) = mpsc::channel(200);\n        let (heartbeat_tx, heartbeat_rx) = mpsc::channel(1);\n\n        Self {\n            id: sid,\n            protocol: ProtocolVersion::V4,\n            transport: AtomicU8::new(TransportType::Websocket as u8),\n\n            internal_rx: Mutex::new(PeekableReceiver::new(internal_rx)),\n            internal_tx,\n\n            heartbeat_rx: Mutex::new(heartbeat_rx),\n            heartbeat_tx,\n            heartbeat_handle: Mutex::new(None),\n            close_fn,\n\n            data: D::default(),\n            req_parts: http::Request::<()>::default().into_parts().0,\n\n            #[cfg(feature = \"v3\")]\n            supports_binary: true,\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engineioxide/src/socket.rs b/engineioxide/src/socket.rs
--- a/engineioxide/src/socket.rs	(revision b9e22e03ae80f41e2720111afaae748e8d38bbae)
+++ b/engineioxide/src/socket.rs	(date 1703514694297)
@@ -222,7 +222,7 @@
     }
 
     /// Sends a packet to the connection.
-    pub(crate) fn send(&self, packet: Packet) -> Result<(), TrySendError<Packet>> {
+    pub fn send(&self, packet: Packet) -> Result<(), TrySendError<Packet>> {
         #[cfg(feature = "tracing")]
         tracing::debug!("[sid={}] sending packet: {:?}", self.id, packet);
         self.internal_tx.try_send(packet)?;
Index: examples/axum-echo/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/examples/axum-echo/index.js b/examples/axum-echo/index.js
new file mode 100644
--- /dev/null	(date 1703506891537)
+++ b/examples/axum-echo/index.js	(date 1703506891537)
@@ -0,0 +1,26 @@
+import {io} from "socket.io-client";
+
+const socket = io("http://localhost:3000");
+const enc = new TextEncoder();
+var counter = 0;
+
+socket.on("connect", () => {
+    socket.emit("message-with-ack", "message-with-binary", enc.encode("message-with-nice"), (...data) => {
+        console.log(`Got: ${data}`);
+    });
+
+    socket.emit("message-with-ack", {
+        some_cool_message: "some cool message but fr this time",
+        binary_data: enc.encode("some ultra fancy binary data")
+    }, (...data) => {
+        console.log(`Got: ${data}`);
+    });
+
+    socket.emit("message-with-ack", 1, "2", { 3: ["4"], 5: [6] }, enc.encode("message-with-nice"), enc.encode("ok"), (...data) => {
+        console.log(`Got: ${JSON.stringify(data)}`);
+    });
+
+    socket.emit("message-with-ack", "nice", enc.encode("nice-2"), "nice-3", enc.encode("nice-4"), (...data) => {
+        console.log(`Got: ${JSON.stringify(data)}`);
+    });
+});
\ No newline at end of file
Index: examples/basic-crud-application/src/handlers/todo.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use std::{collections::HashMap, sync::RwLock};\n\nuse serde::{Deserialize, Serialize};\nuse socketioxide::extract::{AckSender, Data, SocketRef, State};\nuse tracing::info;\nuse uuid::Uuid;\n\nuse crate::handlers::events::Response;\n\nuse super::events::Error;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Todo {\n    id: Uuid,\n    #[serde(flatten)]\n    inner: PartialTodo,\n}\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PartialTodo {\n    completed: bool,\n    title: String,\n}\n\n#[derive(Default)]\npub struct Todos(RwLock<HashMap<Uuid, Todo>>);\nimpl Todos {\n    fn insert(&self, id: Uuid, todo: Todo) {\n        self.0.write().unwrap().insert(id, todo);\n    }\n    fn get(&self, id: &Uuid) -> Option<Todo> {\n        self.0.read().unwrap().get(id).cloned()\n    }\n    fn get_mut(&self, id: &Uuid) -> Option<Todo> {\n        self.0.write().unwrap().get_mut(id).cloned()\n    }\n    fn remove(&self, id: &Uuid) -> Option<Todo> {\n        self.0.write().unwrap().remove(id)\n    }\n    fn get_all(&self) -> Vec<Todo> {\n        self.0.read().unwrap().values().cloned().collect()\n    }\n}\n\npub fn create(s: SocketRef, Data(data): Data<PartialTodo>, ack: AckSender, todos: State<Todos>) {\n    let id = Uuid::new_v4();\n    let todo = Todo { id, inner: data };\n\n    todos.insert(id, todo.clone());\n\n    let res: Response<_> = id.into();\n    ack.send(res).ok();\n\n    s.broadcast().emit(\"todo:created\", todo).ok();\n}\n\npub async fn read(Data(id): Data<Uuid>, ack: AckSender, todos: State<Todos>) {\n    let todo = todos.get(&id).ok_or(Error::NotFound);\n    ack.send(todo).ok();\n}\n\npub async fn update(s: SocketRef, Data(data): Data<Todo>, ack: AckSender, todos: State<Todos>) {\n    let res = todos\n        .get_mut(&data.id)\n        .ok_or(Error::NotFound)\n        .map(|mut todo| {\n            todo.inner = data.inner.clone();\n            s.broadcast().emit(\"todo:updated\", data).ok();\n        });\n\n    ack.send(res).ok();\n}\n\npub async fn delete(s: SocketRef, Data(id): Data<Uuid>, ack: AckSender, todos: State<Todos>) {\n    let res = todos.remove(&id).ok_or(Error::NotFound).map(|_| {\n        s.broadcast().emit(\"todo:deleted\", id).ok();\n    });\n\n    ack.send(res).ok();\n}\n\npub async fn list(ack: AckSender, todos: State<Todos>) {\n    let res: Response<_> = todos.get_all().into();\n    info!(\"Sending todos: {:?}\", res);\n    ack.send(res).ok();\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/examples/basic-crud-application/src/handlers/todo.rs b/examples/basic-crud-application/src/handlers/todo.rs
--- a/examples/basic-crud-application/src/handlers/todo.rs	(revision b9e22e03ae80f41e2720111afaae748e8d38bbae)
+++ b/examples/basic-crud-application/src/handlers/todo.rs	(date 1703260261637)
@@ -45,6 +45,8 @@
     let id = Uuid::new_v4();
     let todo = Todo { id, inner: data };
 
+    println!("Creating todo: {:?}", todo);
+
     todos.insert(id, todo.clone());
 
     let res: Response<_> = id.into();
Index: socketioxide/src/lib.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#![cfg_attr(docsrs, feature(doc_cfg))]\n#![warn(\n    clippy::all,\n    clippy::todo,\n    clippy::empty_enum,\n    clippy::mem_forget,\n    clippy::unused_self,\n    clippy::filter_map_next,\n    clippy::needless_continue,\n    clippy::needless_borrow,\n    clippy::match_wildcard_for_single_variants,\n    clippy::if_let_mutex,\n    clippy::mismatched_target_os,\n    clippy::await_holding_lock,\n    clippy::match_on_vec_items,\n    clippy::imprecise_flops,\n    clippy::suboptimal_flops,\n    clippy::lossy_float_literal,\n    clippy::rest_pat_in_fully_bound_structs,\n    clippy::fn_params_excessive_bools,\n    clippy::exit,\n    clippy::inefficient_to_string,\n    clippy::linkedlist,\n    clippy::macro_use_imports,\n    clippy::option_option,\n    clippy::verbose_file_reads,\n    clippy::unnested_or_patterns,\n    rust_2018_idioms,\n    future_incompatible,\n    nonstandard_style,\n    missing_docs\n)]\n//! Socketioxide is a socket.io server implementation that works as a [`tower`] layer/service.\n//! It integrates nicely with the rest of the [`tower`]/[`tokio`]/[`hyper`](https://docs.rs/hyper/latest/hyper/) ecosystem.\n//!\n//! ## Table of contents\n//! * [Features](#features)\n//! * [Compatibility](#compatibility)\n//! * [Usage](#usage)\n//! * [Initialisation](#initialisation)\n//! * [Handlers](#handlers)\n//! * [Extractors](#extractors)\n//! * [Events](#events)\n//! * [Emiting data](#emiting-data)\n//! * [Acknowledgements](#acknowledgements)\n//! * [State management](#state-management)\n//! * [Adapters](#adapters)\n//! * [Feature flags](#feature-flags)\n//!\n//! ## Features\n//! * Easy to use flexible axum-like API\n//! * Fully compatible with the official [socket.io client](https://socket.io/docs/v4/client-api/)\n//! * Support for the previous version of the protocol (v4).\n//! * State Management\n//! * Namespaces\n//! * Rooms\n//! * Acknowledgements\n//! * Polling & Websocket transports\n//!\n//! ## Compatibility\n//! Because it works as a tower [`layer`](tower::layer)/[`service`](tower::Service) or an hyper [`service`](hyper::service::Service)\n//! you can use it with any http server frameworks that works with tower/hyper:\n//! * [Axum](https://docs.rs/axum/latest/axum/)\n//! * [Warp](https://docs.rs/warp/latest/warp/) (Not supported with socketioxide >= 0.9.0 as long as warp doesn't migrate to hyper v1)\n//! * [Hyper](https://docs.rs/hyper/latest/hyper/)\n//! * [Salvo](https://docs.rs/salvo/latest/salvo/)\n//!\n//! Check the [examples](http://github.com/totodore/socketioxide/tree/main/examples) for more details on frameworks integration.\n//!\n//! ## Usage\n//! The API tries to mimic the equivalent JS API as much as possible. The main difference is that the default namespace `/` is not created automatically, you need to create it manually.\n//!\n//! #### Basic example with axum:\n//! ```no_run\n//! use axum::routing::get;\n//! use socketioxide::{\n//!     extract::SocketRef,\n//!     SocketIo,\n//! };\n//! #[tokio::main]\n//! async fn main() -> Result<(), Box<dyn std::error::Error>> {\n//!     let (layer, io) = SocketIo::new_layer();\n//!\n//!     // Register a handler for the default namespace\n//!     io.ns(\"/\", |s: SocketRef| {\n//!         // For each \"message\" event received, send a \"message-back\" event with the \"Hello World!\" event\n//!         s.on(\"message\", |s: SocketRef| {\n//!             s.emit(\"message-back\", \"Hello World!\").ok();\n//!         });\n//!     });\n//!\n//!     let app = axum::Router::new()\n//!     .route(\"/\", get(|| async { \"Hello, World!\" }))\n//!     .layer(layer);\n//!\n//!     let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\n//!     axum::serve(listener, app).await.unwrap();\n//!\n//!     Ok(())\n//! }\n//! ```\n//! ## Initialisation\n//! The [`SocketIo`] struct is the main entry point of the library. It is used to create a [`Layer`](tower::layer) or a [`Service`](tower::Service).\n//! Later it can be used as the equivalent of the `io` object in the JS API.\n//!\n//! When creating your [`SocketIo`] instance, you can use the builder pattern to configure it with the [`SocketIoBuilder`] struct.\n//! * See the [`SocketIoBuilder`] doc for more details on the available configuration options.\n//! * See the [`layer`] module doc for more details on layers.\n//! * See the [`service`] module doc for more details on services.\n//!\n//! #### Tower layer example with custom configuration:\n//! ```\n//! use socketioxide::SocketIo;\n//! let (layer, io) = SocketIo::builder()\n//!     .max_payload(10_000_000) // Max HTTP payload size of 10M\n//!     .max_buffer_size(10_000) // Max number of packets in the buffer\n//!     .build_layer();\n//! ```\n//!\n//! #### Tower _standalone_ service example with default configuration:\n//! ```\n//! use socketioxide::SocketIo;\n//! let (svc, io) = SocketIo::new_svc();\n//! ```\n//!\n//! ## Handlers\n//! Handlers are functions or clonable closures that are given to the `io.ns`, the `socket.on` and the `socket.on_disconnect` fns.\n//! They can be async or sync and can take from 0 to 16 arguments that implements the [`FromConnectParts`](handler::FromConnectParts)\n//! trait for the [`ConnectHandler`](handler::ConnectHandler), the [`FromMessageParts`](handler::FromMessageParts) for\n//! the [`MessageHandler`](handler::MessageHandler) and the [`FromDisconnectParts`](handler::FromDisconnectParts) for\n//! the [`DisconnectHandler`](handler::DisconnectHandler).\n//! They are greatly inspired by the axum handlers.\n//!\n//! If they are async, a new task will be spawned for each incoming connection/message so it doesn't block the event management task.\n//!\n//! * Check the [`handler::connect`] module doc for more details on the connect handler\n//! * Check the [`handler::message`] module doc for more details on the message handler.\n//! * Check the [`handler::disconnect`] module doc for more details on the disconnect handler.\n//! * Check the [`handler::extract`] module doc for more details on the extractors.\n//!\n//! ## Extractors\n//! Handlers params are called extractors and are used to extract data from the incoming connection/message. They are inspired by the axum extractors.\n//! An extractor is a struct that implements the [`FromConnectParts`](handler::FromConnectParts) trait for the [`ConnectHandler`](handler::ConnectHandler)\n//! the [`FromMessageParts`](handler::FromMessageParts) for the [`MessageHandler`](handler::MessageHandler) and the\n//! [`FromDisconnectParts`](handler::FromDisconnectParts) for the [`DisconnectHandler`](handler::DisconnectHandler).\n//!\n//! Here are some examples of extractors:\n//! * [`Data`](extract::Data): extracts and deserialize to json any data, if a deserialize error occurs the handler won't be called\n//!     - for [`ConnectHandler`](handler::ConnectHandler): extracts and deserialize to json the auth data\n//!     - for [`MessageHandler`](handler::MessageHandler): extracts and deserialize to json the message data\n//! * [`TryData`](extract::Data): extracts and deserialize to json any data but with a `Result` type in case of error\n//!     - for [`ConnectHandler`](handler::ConnectHandler): extracts and deserialize to json the auth data\n//!     - for [`MessageHandler`](handler::MessageHandler): extracts and deserialize to json the message data\n//! * [`SocketRef`](extract::Data): extracts a reference to the [`Socket`](socket::Socket)\n//! * [`Bin`](extract::Data): extract a binary payload for a given message. Because it consumes the event it should be the last argument\n//! * [`AckSender`](extract::Data): Can be used to send an ack response to the current message event\n//! * [`ProtocolVersion`]: extracts the protocol version of the socket\n//! * [`TransportType`]: extracts the transport type of the socket\n//! * [`DisconnectReason`](crate::socket::DisconnectReason): extracts the reason of the disconnection\n//! * [`State`](extract::State): extracts a reference to a state previously set with [`SocketIoBuilder::with_state`](crate::io::SocketIoBuilder).\n//! ### Extractor order\n//! Extractors are run in the order of their declaration in the handler signature. If an extractor returns an error, the handler won't be called and a `tracing::error!` call will be emitted if the `tracing` feature is enabled.\n//!\n//! For the [`MessageHandler`](handler::MessageHandler), some extractors require to _consume_ the event and therefore only implement the [`FromMessage`](handler::FromMessage) trait, like the [`Bin`](extract::Bin) extractor, therefore they should be the last argument.\n//!\n//! Note that any extractors that implement the [`FromMessageParts`](handler::FromMessageParts) also implement by default the [`FromMessage`](handler::FromMessage) trait.\n//!\n//! ## Events\n//! There are three types of events:\n//! * The connect event is emitted when a new connection is established. It can be handled with the [`ConnectHandler`](handler::ConnectHandler) and the `io.ns` method.\n//! * The message event is emitted when a new message is received. It can be handled with the [`MessageHandler`](handler::MessageHandler) and the `socket.on` method.\n//! * The disconnect event is emitted when a socket is closed. It can be handled with the [`DisconnectHandler`](handler::DisconnectHandler) and the `socket.on_disconnect` method.\n//!\n//! Only one handler can exist for an event so registering a new handler for an event will replace the previous one.\n//!\n//! ## [Emiting data](#emiting-data)\n//! Data can be emitted to a socket with the [`Socket::emit`](socket::Socket) method. It takes an event name and a data argument.\n//! The data argument can be any type that implements the [`serde::Serialize`] trait.\n//!\n//! You can emit from the [`SocketIo`] handle or the [`SocketRef`](extract::SocketRef).\n//! The difference is that you can move the [`io`](SocketIo) handle everywhere because it is a cheaply cloneable struct.\n//! The [`SocketRef`](extract::SocketRef) is a reference to the socket and cannot be cloned.\n//!\n//! Moreover the [`io`](SocketIo) handle can emit to any namespace while the [`SocketRef`](extract::SocketRef) can only emit to the namespace of the socket.\n//!\n//! #### Emit errors\n//! If the data can't be serialized to json, an [`serde_json::Error`] will be returned.\n//! If the socket is disconnected or the internal channel is full, a tracing log will be emitted if the `tracing` feature is enabled and the message will be dropped.\n//! This solution is not ideal and will be improved in the future (see [socketioxide/172](https://github.com/Totodore/socketioxide/issues/172)).\n//!\n//! #### Emitting with operators\n//! To configure the emit, you can chain [`Operators`](operators::Operators) methods to the emit call. With that you can easily configure the following options:\n//! * rooms: emit, join, leave to specific rooms\n//! * namespace: emit to a specific namespace (only from the [`SocketIo`] handle)\n//! * timeout: set a custom timeout when waiting for an ack\n//! * binary: emit a binary payload with the message\n//! * local: broadcast only to the current node (in case of a cluster)\n//!\n//! Check the [`operators::Operators`] doc for more details on the operators.\n//!\n//! ## Acknowledgements\n//! You can ensure that a message has been received by the client/server with acknowledgements.\n//!\n//! #### Server acknowledgements\n//! They are implemented with the [`AckSender`](extract::AckSender) extractor.\n//! You can send an ack response with an optional binary payload with the [`AckSender::send`](extract::AckSender) method.\n//! If the client doesn't send an ack response, the [`AckSender::send`](extract::AckSender) method will do nothing.\n//!\n//! #### Client acknowledgements\n//! You can use the [`Socket::emit_with_ack`](socket::Socket) method to emit a message with an ack callback.\n//! It will return a [`Future`](futures::Future) that will resolve when the acknowledgement is received.\n//!\n//! ## [State management](#state-management)\n//! There are two ways to manage the state of the server:\n//!\n//! #### Per socket state\n//! You can enable the `extensions` feature and use the [`extensions`](socket::Socket::extensions) field on any socket to manage\n//! the state of each socket. It is backed by a [`dashmap`] so you can safely access it from multiple threads.\n//! Beware that deadlocks can easily occur if you hold a value ref and try to remove it at the same time.\n//! See the [`extensions`] module doc for more details.\n//!\n//! #### Global state\n//! You can enable the `state` feature and use [`SocketIoBuilder::with_state`](SocketIoBuilder) method to set\n//! multiple global states for the server. You can then access them from any handler with the [`State`](extract::State) extractor.\n//!\n//! Because the global state is staticaly defined, beware that the state map will exist for the whole lifetime of the program even\n//! if you drop everything and close you socket.io server. This is a limitation because of the impossibility to have extractors with lifetimes,\n//! therefore state references must be `'static`.\n//!\n//! Another limitation is that because it is common to the whole server. If you build a second server, it will share the same state.\n//! Also if the first server is already started you won't be able to add new states because states are frozen at the start of the first server.\n//!\n//! ## Adapters\n//! This library is designed to work with clustering. It uses the [`Adapter`](adapter::Adapter) trait to abstract the underlying storage.\n//! By default it uses the [`LocalAdapter`](adapter::LocalAdapter) which is a simple in-memory adapter.\n//! Currently there is no other adapters available but more will be added in the future.\n//!\n//! ## [Feature flags](#feature-flags)\n//! * `v4`: enable support for the socket.io protocol v4\n//! * `tracing`: enable logging with [`tracing`] calls\n//! * `extensions`: enable per-socket state with the [`extensions`] module\n//! * `state`: enable global state management\n//!\npub mod adapter;\n\n#[cfg_attr(docsrs, doc(cfg(feature = \"extensions\")))]\n#[cfg(feature = \"extensions\")]\npub mod extensions;\n#[cfg(feature = \"state\")]\nmod state;\n\npub mod handler;\npub mod layer;\npub mod operators;\npub mod service;\npub mod socket;\n\n#[cfg(feature = \"test-utils\")]\npub use packet::*;\n\npub use engineioxide::TransportType;\npub use errors::{AckError, BroadcastError, SendError};\npub use handler::extract;\npub use io::{SocketIo, SocketIoBuilder, SocketIoConfig};\n\nmod client;\nmod errors;\nmod io;\nmod ns;\nmod packet;\n\n/// Socket.IO protocol version.\n/// It is accessible with the [`Socket::protocol`](socket::Socket) method or as an extractor\n///\n/// **Note**: The socket.io protocol version does not correspond to the engine.io protocol version.\n#[derive(Debug, Copy, Clone, PartialEq)]\npub enum ProtocolVersion {\n    /// The socket.io protocol version 4, only available with the feature flag `v4`\n    V4 = 4,\n    /// The socket.io protocol version 5, enabled by default\n    V5 = 5,\n}\n\nimpl From<ProtocolVersion> for engineioxide::ProtocolVersion {\n    fn from(value: ProtocolVersion) -> Self {\n        match value {\n            ProtocolVersion::V4 => Self::V3,\n            ProtocolVersion::V5 => Self::V4,\n        }\n    }\n}\nimpl From<engineioxide::ProtocolVersion> for ProtocolVersion {\n    fn from(value: engineioxide::ProtocolVersion) -> Self {\n        match value {\n            engineioxide::ProtocolVersion::V3 => Self::V4,\n            engineioxide::ProtocolVersion::V4 => Self::V5,\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/socketioxide/src/lib.rs b/socketioxide/src/lib.rs
--- a/socketioxide/src/lib.rs	(revision b9e22e03ae80f41e2720111afaae748e8d38bbae)
+++ b/socketioxide/src/lib.rs	(date 1703514219416)
@@ -268,6 +268,7 @@
 mod io;
 mod ns;
 mod packet;
+mod operators_single;
 
 /// Socket.IO protocol version.
 /// It is accessible with the [`Socket::protocol`](socket::Socket) method or as an extractor
Index: examples/basic-crud-application/src/main.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use socketioxide::{extract::SocketRef, SocketIo};\nuse tower::ServiceBuilder;\nuse tower_http::{cors::CorsLayer, services::ServeDir};\nuse tracing::info;\nuse tracing_subscriber::FmtSubscriber;\n\nuse crate::handlers::todo::Todos;\n\nmod handlers;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let subscriber = FmtSubscriber::new();\n\n    tracing::subscriber::set_global_default(subscriber)?;\n\n    info!(\"Starting server\");\n\n    let (layer, io) = SocketIo::builder()\n        .with_state(Todos::default())\n        .build_layer();\n\n    io.ns(\"/\", |s: SocketRef| {\n        s.on(\"todo:create\", handlers::todo::create);\n        s.on(\"todo:read\", handlers::todo::read);\n        s.on(\"todo:update\", handlers::todo::update);\n        s.on(\"todo:delete\", handlers::todo::delete);\n        s.on(\"todo:list\", handlers::todo::list);\n    });\n\n    let app = axum::Router::new()\n        .nest_service(\"/\", ServeDir::new(\"dist\"))\n        .layer(\n            ServiceBuilder::new()\n                .layer(CorsLayer::permissive()) // Enable CORS policy\n                .layer(layer),\n        );\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\n    axum::serve(listener, app).await.unwrap();\n\n    Ok(())\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/examples/basic-crud-application/src/main.rs b/examples/basic-crud-application/src/main.rs
--- a/examples/basic-crud-application/src/main.rs	(revision b9e22e03ae80f41e2720111afaae748e8d38bbae)
+++ b/examples/basic-crud-application/src/main.rs	(date 1703260073635)
@@ -36,7 +36,7 @@
                 .layer(layer),
         );
 
-    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
+    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000").await.unwrap();
     axum::serve(listener, app).await.unwrap();
 
     Ok(())
